[{"title":"Hello World","url":"/2026/02/08/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n"},{"title":"共轭梯度法中参数alpha和beta的推导","url":"/2026/02/08/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/%E5%85%B1%E8%BD%AD%E6%A2%AF%E5%BA%A6%E6%B3%95%E4%B8%AD%E5%8F%82%E6%95%B0alpha%E5%92%8Cbeta%E7%9A%84%E6%8E%A8%E5%AF%BC/","content":"/ 强制让 MathJax 公式容器支持横向滚动 /.mjx-container, .MathJax_Display, .MathJax {    overflow-x: auto !important; / 超出宽度时显示滚动条 /    overflow-y: hidden;          / 隐藏垂直滚动条 /    max-width: 100%;             / 限制最大宽度为屏幕宽度 /    -webkit-overflow-scrolling: touch; / 优化移动端滑动体验 /}\n我们在这里推导$\\mathbf{p}k = \\mathbf{r}_k + \\beta{k-1} \\mathbf{p}_{k-1}$中的参数$\\alpha$和$\\beta$\n$\\alpha_k$ 的推导我们现在的目标是：在已知当前位置 $\\mathbf{x}k$ 和搜索方向 $\\mathbf{p}_k$ 的情况下，确定我们要走多远这意味着我们要选择一个 $\\alpha_k$，使得函数 $\\varphi$ 在这条直线上达到最小值。我们将 $\\mathbf{x}{k+1} = \\mathbf{x}_k + \\alpha \\mathbf{p}_k$ 代入 $\\varphi(\\mathbf{u})$ 的表达式中，把 $\\varphi$ 看作只关于 $\\alpha$ 的函数 $f(\\alpha)$：\n\nf(\\alpha) = \\varphi(\\mathbf{x}_k + \\alpha \\mathbf{p}_k)展开 $\\varphi(\\mathbf{u}) = \\mathbf{u}^T \\mathbf{A} \\mathbf{u} - 2\\mathbf{u}^T \\mathbf{b}$\n\nf(\\alpha) = (\\mathbf{x}_k + \\alpha \\mathbf{p}_k)^T \\mathbf{A} (\\mathbf{x}_k + \\alpha \\mathbf{p}_k) - 2(\\mathbf{x}_k + \\alpha \\mathbf{p}_k)^T \\mathbf{b}展开括号（利用 $\\mathbf{A}$ 的对称性，$\\mathbf{x}_k^T \\mathbf{A} \\mathbf{p}_k = \\mathbf{p}_k^T \\mathbf{A} \\mathbf{x}_k$）\n\nf(\\alpha) = \\underbrace{\\mathbf{x}_k^T \\mathbf{A} \\mathbf{x}_k - 2\\mathbf{x}_k^T \\mathbf{b}}_{\\text{常数项}} + 2\\alpha \\mathbf{p}_k^T \\mathbf{A} \\mathbf{x}_k + \\alpha^2 \\mathbf{p}_k^T \\mathbf{A} \\mathbf{p}_k - 2\\alpha \\mathbf{p}_k^T \\mathbf{b}为了求最小值，我们对 $\\alpha$ 求导，并令导数为 $0$\n\n\\frac{d f(\\alpha)}{d \\alpha} = 2 \\mathbf{p}_k^T \\mathbf{A} \\mathbf{x}_k + 2\\alpha \\mathbf{p}_k^T \\mathbf{A} \\mathbf{p}_k - 2 \\mathbf{p}_k^T \\mathbf{b} = 0整理\n\n\\alpha (\\mathbf{p}_k^T \\mathbf{A} \\mathbf{p}_k) + \\mathbf{p}_k^T (\\mathbf{A} \\mathbf{x}_k - \\mathbf{b}) = 0因为 $\\mathbf{A} \\mathbf{x}_k - \\mathbf{b} = -\\mathbf{r}_k$，所以\n\n\\alpha (\\mathbf{p}_k^T \\mathbf{A} \\mathbf{p}_k) - \\mathbf{p}_k^T \\mathbf{r}_k = 0最后解出 $\\alpha$\n\n\\alpha_k = \\frac{\\mathbf{p}_k^T \\mathbf{r}_k}{\\mathbf{p}_k^T \\mathbf{A} \\mathbf{p}_k}你会发现上面的公式分子是 $\\mathbf{p}k^T \\mathbf{r}_k$，但在最终算法里我们写的是 $\\mathbf{r}_k^T \\mathbf{r}_k$。为什么它们会相等？回顾 $\\mathbf{p}_k$ 的定义：$\\mathbf{p}_k = \\mathbf{r}_k + \\beta{k-1} \\mathbf{p}_{k-1}$。两边同时左乘 $\\mathbf{r}_k^T$\n\n\\mathbf{r}_k^T \\mathbf{p}_k = \\mathbf{r}_k^T \\mathbf{r}_k + \\beta_{k-1} \\underbrace{\\mathbf{r}_k^T \\mathbf{p}_{k-1}}_{0}在共轭梯度法中，有一个重要的性质：当前的残差 $\\mathbf{r}k$ 与旧的搜索方向 $\\mathbf{p}{k-1}$ 正交（即 $\\mathbf{r}k^T \\mathbf{p}{k-1} = 0$）因此，分子可以简化为\n\n\\mathbf{p}_k^T \\mathbf{r}_k = \\mathbf{r}_k^T \\mathbf{r}_k最终得到\n\n\\alpha_k = \\frac{\\mathbf{r}_k^T \\mathbf{r}_k}{\\mathbf{p}_k^T \\mathbf{A} \\mathbf{p}_k}$\\beta_k$ 的推导我们在算法中定义了搜索方向的更新公式：\n\n\\mathbf{p}_{k+1} = \\mathbf{r}_{k+1} + \\beta_k \\mathbf{p}_k我们的目标是找到一个合适的 $\\betak$，使得新的方向 $\\mathbf{p}{k+1}$ 与旧的方向 $\\mathbf{p}_k$ 关于矩阵 $\\mathbf{A}$ 共轭\n列出共轭条件根据共轭梯度的定义，我们需要\n\n\\mathbf{p}_{k+1}^T \\mathbf{A} \\mathbf{p}_k = 0将 $\\mathbf{p}_{k+1}$ 的定义代入上述条件中\n\n(\\mathbf{r}_{k+1} + \\beta_k \\mathbf{p}_k)^T \\mathbf{A} \\mathbf{p}_k = 0展开括号\n\n\\mathbf{r}_{k+1}^T \\mathbf{A} \\mathbf{p}_k + \\beta_k \\mathbf{p}_k^T \\mathbf{A} \\mathbf{p}_k = 0移项并求解 $\\beta_k$\n\n\\beta_k = - \\frac{\\mathbf{r}_{k+1}^T \\mathbf{A} \\mathbf{p}_k}{\\mathbf{p}_k^T \\mathbf{A} \\mathbf{p}_k}这个公式虽然正确，但计算起来很麻烦（需要做矩阵乘法 $\\mathbf{A}\\mathbf{p}k$）。我们可以利用 $\\alpha_k$ 的更新公式来化简它。回顾残差的更新公式：$\\mathbf{r}{k+1} = \\mathbf{r}_k - \\alpha_k \\mathbf{A} \\mathbf{p}_k$。我们可以反解出 $\\mathbf{A} \\mathbf{p}_k$：\n\n\\mathbf{A} \\mathbf{p}_k = -\\frac{1}{\\alpha_k} (\\mathbf{r}_{k+1} - \\mathbf{r}_k)将这个式子代入 $\\beta_k$ 分子的 $\\mathbf{A} \\mathbf{p}_k$ 中：\n\n\\text{分子} = \\mathbf{r}_{k+1}^T \\mathbf{A} \\mathbf{p}_k = \\mathbf{r}_{k+1}^T \\left[ -\\frac{1}{\\alpha_k} (\\mathbf{r}_{k+1} - \\mathbf{r}_k) \\right]\n= -\\frac{1}{\\alpha_k} (\\mathbf{r}_{k+1}^T \\mathbf{r}_{k+1} - \\underbrace{\\mathbf{r}_{k+1}^T \\mathbf{r}_k}_{0})又因为新残差与旧残差正交 ($\\mathbf{r}_{k+1}^T \\mathbf{r}_k = 0$)，所以分子简化为\n\n-\\frac{1}{\\alpha_k} \\mathbf{r}_{k+1}^T \\mathbf{r}_{k+1}\n$$现在看分母，回顾 $\\alpha_k = \\frac{\\mathbf{r}_k^T \\mathbf{r}_k}{\\mathbf{p}_k^T \\mathbf{A} \\mathbf{p}_k}$，所以分母其实等于：\\mathbf{p}_k^T \\mathbf{A} \\mathbf{p}_k = \\frac{\\mathbf{r}_k^T \\mathbf{r}_k}{\\alpha_k}\n\n化简后分子和分母相除\\betak = - \\frac{-\\frac{1}{\\alpha_k} \\mathbf{r}{k+1}^T \\mathbf{r}_{k+1}}{\\frac{1}{\\alpha_k} \\mathbf{r}_k^T \\mathbf{r}_k}\n\n\n消去 $-\\frac{1}{\\alpha_k}$ 和 $\\frac{1}{\\alpha_k}$，最终就得到\\betak = \\frac{\\mathbf{r}{k+1}^T \\mathbf{r}_{k+1}}{\\mathbf{r}_k^T \\mathbf{r}_k}$$\n","tags":["数值分析"]},{"title":"Adam算法","url":"/2026/02/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Adam%E7%AE%97%E6%B3%95/","content":"/ 强制让 MathJax 公式容器支持横向滚动 /.mjx-container, .MathJax_Display, .MathJax {    overflow-x: auto !important; / 超出宽度时显示滚动条 /    overflow-y: hidden;          / 隐藏垂直滚动条 /    max-width: 100%;             / 限制最大宽度为屏幕宽度 /    -webkit-overflow-scrolling: touch; / 优化移动端滑动体验 /}\n\n偏差我们完成了Momentum和RMSProp如果我们将两者拼凑在一起\n\n更新一阶矩（动量）\n\n\nm_t = \\beta_1 m_{t-1} + (1-\\beta_1) \\mathbf{g}_t\n更新二阶矩（自适应项）\n\n\nv_t = \\beta_2 v_{t-1} + (1-\\beta_2) \\mathbf{g}_t^2\n参数更新\n\n\n\\mathbf{x}_{t+1} = \\mathbf{x}_t - \\eta \\frac{m_t}{\\sqrt{v_t} + \\epsilon}其中 $\\beta_1$ 通常为 0.9，$\\beta_2$ 通常为 0.999接下来让我们看看当$t=1$时发生了什么假设我们将$m_0,v_0$初始化为$\\mathbf{0}$向量带入公式\n\nv_1 = \\beta_2 \\cdot 0 + (1-\\beta_2) \\mathbf{g}_1^2 = (1 - 0.999) \\mathbf{g}_1^2 = 0.001 \\cdot \\mathbf{g}_1^2我们观察到，计算出的二阶矩估计值仅为真实梯度平方的0.001倍！这意味着估计值严重偏向于0如果直接用这个$v_t$去做分母$\\sqrt{v_1}$，分母会极小，导致更新步长会爆炸性地变大（或者在 $m_t$ 上导致步长极小，取决于分子分母谁偏得更多）这种初始化偏差会导致训练初期极其不稳定\n修正为了消除这个偏差，我们需要从统计学角度推导一个修正系数\n我们先作一个期望分析假设真实梯度的二阶矩是平稳的（Stationary），记为 $E[\\mathbf{g}^2]$。我们希望我们的估计量 $v_t$ 是无偏的，即希望 $E[v_t] = E[\\mathbf{g}^2]$\n让我们展开 $v_t$ 的递归式\n\nv_t = (1-\\beta_2) \\sum_{i=1}^t \\beta_2^{t-i} \\mathbf{g}_i^2对两边求期望 $E[\\cdot]$\n\n\\begin{aligned} \nE[v_t] &= E\\left[ (1-\\beta_2) \\sum_{i=1}^t \\beta_2^{t-i} \\mathbf{g}_i^2 \\right] \\\\ &= (1-\\beta_2) \\sum_{i=1}^t \\beta_2^{t-i} E[\\mathbf{g}_i^2] \\\\ &\\approx (1-\\beta_2) E[\\mathbf{g}^2] \\sum_{i=1}^t \\beta_2^{t-i} \n\\end{aligned}这里 $\\sum_{i=1}^t \\beta_2^{t-i}$ 是一个等比数列求和，其值为\n\n\\sum_{k=0}^{t-1} \\beta_2^k = \\frac{1 - \\beta_2^t}{1 - \\beta_2}代回期望公式\n\n\\begin{aligned}\nE[v_t] &\\approx (1-\\beta_2) E[\\mathbf{g}^2] \\cdot \\frac{1 - \\beta_2^t}{1 - \\beta_2} \\\\ &= E[\\mathbf{g}^2] \\cdot (1 - \\beta_2^t) \n\\end{aligned}我们发现，\n\nE[v_t] = \\text{真实值} \\times (1 - \\beta_2^t)为了得到真实值，我们必须人为的除以系数$1 - \\beta_2^t$\n\n当 $t$ 很小时，$\\beta_2^t = 0.999$，修正因子 $1 - 0.999 = 0.001$。我们把 $v_t$ 除以 $0.001$，正好把它放大了 1000 倍，还原了真实量级\n当 $t$ 很大时，$\\beta_2^t \\to 0$，修正因子 $\\to 1$。此时不再需要修正，因为 EMA 已经积累了足够的数据，偏差自然消失了同理，对一阶矩 $m_t$ 也需要除以 $(1 - \\beta_1^t)$\n\n结合上述所有推导，我们得到完整的Adam算法流程迭代过程 (在时刻 $t$)：计算梯度：\n\n\\mathbf{g}_t = \\nabla f(\\mathbf{x}_{t-1}) 更新一阶矩：\nm_t = \\beta_1 m_{t-1} + (1-\\beta_1) \\mathbf{g}_t更新二阶矩：\nv_t = \\beta_2 v_{t-1} + (1-\\beta_2) \\mathbf{g}_t^2计算偏差修正后的一阶矩：\n\n\\hat{m}_t = \\frac{m_t}{1 - \\beta_1^t}计算偏差修正后的二阶矩：\n\n\\hat{v}_t = \\frac{v_t}{1 - \\beta_2^t}计算参数更新：\n\n\\mathbf{x}_t = \\mathbf{x}_{t-1} - \\alpha \\cdot \\frac{\\hat{m}_t}{\\sqrt{\\hat{v}_t} + \\epsilon}","tags":["深度学习"]},{"title":"设计原则与数学推导","url":"/2026/02/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CNN/CNN%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/","content":"/ 强制让 MathJax 公式容器支持横向滚动 /.mjx-container, .MathJax_Display, .MathJax {    overflow-x: auto !important; / 超出宽度时显示滚动条 /    overflow-y: hidden;          / 隐藏垂直滚动条 /    max-width: 100%;             / 限制最大宽度为屏幕宽度 /    -webkit-overflow-scrolling: touch; / 优化移动端滑动体验 /}\n\n原则一：平移不变性假设我们需要检测图像中是否有“一只猫”。无论这只猫位于图像的左上角 $(x1, y_1)$ 还是右下角 $(x_2, y_2)$，它都是猫。 在全连接网络中，识别左上角的权重 $w{top_left}$ 和识别右下角的权重 $w_{bottom_right}$ 是完全独立的。这意味着模型必须在不同位置重新学习什么是“猫我们采用参数共享的解决方案我们不应该为图像的每个位置学习单独的检测器，而应该定义一个通用的检测器（卷积核、滤波器），让它在整个图像上滑动\n\n如果在位置$\\mathbf{A}$检测到了特征$f$，那么同样的检测器在位置$\\mathbf{B}$也应该能检测到特征$f$\n数学上，这意味着函数$f$ 对于输入 $x$ 的平移操作 $T$ 满足 $f(T(x)) = f(x)$\n\n原则二：局部性定理全连接试图试图建立所有像素间的联系，这是及其耗费内存的。因为图像像素具有很强的空间相关性，即像素 $x{i,j}$ 的值与其邻域（如 $x{i+1, j}$）高度相关，但与距离很远的像素（如 $x_{i+500, j+500}$）的相关性几乎为零所以我们采取稀疏连接我们限制神经元只与输入图像的一个小窗口（例如$3\\times3$或者$5\\times5$）相连，这个区域充分地减少了计算量\n原则三：层级与感受野虽然第一层只关注局部，但我们最终需要识别整张图像。局部的线条如何组合成形状，形状又如何组合成物体？我们使用感受野扩张\n\n第 1 层神经元看到 $3 \\times 3$ 的像素\n第 2 层神经元看到第 1 层的 $3 \\times 3$ 个输出，这实际上覆盖了原始图像中更大的区域\n随着层数加深，高层神经元能“看见”原始图像中更广阔的区域，从而捕获全局语义信息\n\n数学形式化我们如何从全连接公式变为卷积公式？对于输入图像 $X$ (展开为一维向量) 和输出 $H$，全连接层定义为\n\nh_i = \\sum_{j} W_{i,j} x_j其中 $W{i,j}$ 表示第 $j$ 个输入像素对第 $i$ 个输出神经元的权重。这包含了所有可能的相互作用根据原则二，神经元 $i$ 只应当受其附近的输入 $j$ 影响。如果 $|i - j| &gt; \\Delta$（$\\Delta$ 为邻域范围），则强制 $W{i,j} = 0$。公式变为\n\nh_i = \\sum_{j=i-\\Delta}^{i+\\Delta} W_{i,j} x_j此时矩阵 $\\mathbf{W}$ 变成了带状矩阵，这是一个稀疏矩阵根据原则一，检测特征的权重不应依赖于具体位置 $i$，即 $W{i, j}$ 不应该取决于 $i$，而只取决于输入和输出的相对位置 $(i-j)$我们将 $W{i,j}$ 替换为 $w_{i-j}$（这里 $w$ 就是我们的卷积核）\n\nh_i = \\sum_{j=i-\\Delta}^{i+\\Delta} w_{i-j} x_j如果我们令 $a = i-j$，则 $j = i-a$。通过变量代换，我们得到标准的离散卷积\n\nh_i = \\sum_{a=-\\Delta}^{\\Delta} w_a x_{i-a}","tags":["卷积神经网络"]},{"title":"test-post","url":"/2026/02/08/test-post/","content":""},{"title":"特征值分布的对称性对于误差的影响的解释","url":"/2026/01/23/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/260123_%E7%89%B9%E5%BE%81%E5%80%BC%E5%88%86%E5%B8%83%E7%9A%84%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%AF%B9%E4%BA%8E%E8%AF%AF%E5%B7%AE%E7%9A%84%E5%BD%B1%E5%93%8D%E7%9A%84%E8%A7%A3%E9%87%8A/","content":"\n/* 强制让 MathJax 公式容器支持横向滚动 */\n.mjx-container, .MathJax_Display, .MathJax {\n    overflow-x: auto !important; /* 超出宽度时显示滚动条 */\n    overflow-y: hidden;          /* 隐藏垂直滚动条 */\n    max-width: 100%;             /* 限制最大宽度为屏幕宽度 */\n    -webkit-overflow-scrolling: touch; /* 优化移动端滑动体验 */\n}\n\n\n我们设$\\mathbf{I}$是一个$100 \\times 100$单位矩阵，$\\mathbf{Z}$是一个$100\\times100$的零矩阵，$\\mathbf{b}$是一个$200\\times1$的全1向量设$\\mathbf{B}=\\begin{bmatrix} 1 &amp; &amp; &amp; \\ &amp; 2 &amp; &amp; \\ &amp; &amp; \\ddots &amp; \\ &amp; &amp; &amp; 100 \\end{bmatrix}$然后，令$\\mathbf{A_1}=\\begin{bmatrix} \\mathbf{B} &amp; \\mathbf{I} \\ \\mathbf{Z} &amp; \\mathbf{B} \\end{bmatrix}$ ，$\\mathbf{A_2}=\\begin{bmatrix} \\mathbf{B} &amp; \\mathbf{I} \\ \\mathbf{Z} &amp; \\mathbf{-B} \\end{bmatrix}$我们使用GMRES算法，分别绘制$\\mathbf{A_1}$与$\\mathbf{A_2}$的残差收敛图，如下图所示\n我们关注两个问题\n1.为什么$A_1$的收敛曲线是光滑的，而$A_2$的是带有折线的？2.为什么$A_1$收敛得更快，而$A_2$收敛极其缓慢？我们先来回顾一下Arnoldi迭代Arnoldi 迭代本质上是在构造一组正交多项式我们生成的基向量$q_1,q_2,q_3\\dots$，其实他们代表了$\\mathbf{A}$的不同次幂作用在$\\mathbf{b}$上\n\n$q_1$：它是$\\mathbf{b}$的归一化   本质：零次多项式$\\phi_0(A)b$\n$q_2$：来自$Aq_1$（并减去了$q_1$分量）   本质：包含$Ab$和$b$，即1次多项式$\\phi_1(A)b$\n$q_3$：来自$Aq_2$   本质：2次多项式$\\phi_2(A)b$这意味着，你的矩阵$Q_m$的每一列，本质上都是一个以向量形式存在的，作用在$b$上的多项式\n\n然后，GMRES算法本质上是在求解一个最小二乘问题，也就是我们通过了这个算法得到了一个用来”形容“$z$的最优多项式，\nmin||H_{m}z-||b||e_{1}||我们会得到一个解向量$\\mathbf{y}=[y_1,y_2,\\dots,y_m]^T$（就是$z$）这是配方，它告诉我们对于多项式的每一项，我们应该取多少项的$q_m$因为$y$是让残差最小的“最优配方”，所以它组合出来的多项式，自然就是最优多项式\n而我们去寻找这个最优多项式，要去令残差$\\mathbf{r}=p(A)\\mathbf{b}$最小，本质上也是去把多项式中特征值的位置（大小）压低。这是什么意思？我们知道，在矩阵$A$张成的空间里，任何一个向量$b$都可以写成这些特征向量的叠加：\n\n\\mathbf{b}=y_1\\mathbf{v_1}+y_2\\mathbf{v_2}+\\dots+y_n\\mathbf{v_n}又有$p(A)\\mathbf{v_i}=p(\\lambda_i)\\mathbf{v_i}$，所以，残差$\\mathbf{r}=p(A)\\mathbf{b}$就可以表示为\n\n\\begin{aligned}\n\\mathbf{r} &= p(A)\\mathbf{b} \\\\\n           &= p(A)(y_1\\mathbf{y_1}+\\dots+y_n\\mathbf{v_n}) \\\\\n           &= y_1p(\\lambda_1)\\mathbf{v_1}+\\dots+y_np(\\lambda_n)\\mathbf{v_n}\n\\end{aligned}所以\n\n||\\mathbf{r}|| \\approx \\sum ||c_ip(\\lambda_i)v_i||我们会发现，如果我们要让残差最小，我们得让$p(\\lambda)$最小，如果你想让残差逼近0，那你就得让$p(\\lambda)=0$\n现在准备工作准备得差不多，我们可以开始看问题了\n\n首先，为什么$A_2$的收敛图像会带有折线？  观察$A_2$的结构，它是一个稀疏矩阵且对角线上的元素值是关于原点对称的，所以我们可以近似认为，这个矩阵的特征值是关于原点对称的。  我们注意到，奇数步时多项式的最高次项是奇数项\n而奇次函数是反对称的：$f(\\lambda)=-f(-\\lambda)$\n这就意味这，如果你想去用奇次项去压低正特征值处的误差，负特征值处的误差就会被放大了。例如，现在我们有一个奇次函数$f(x)=1+cx$，矩阵有特征值1和-1，我们先令$f(1)\\approx0$，即$1+c·(1)\\approx0$，我们取理想值$c=-1$，此时$p(1)=1+(-1)·1=0$，正特征值处的误差被消除了。那我们再看$\\lambda=-1$处发生了什么，同样的$c=-1$，那么$f(-1)=1+(-1)·(-1)=1+1=2$，这与我们上面所提出的一致！误差不仅没变小，反而变大了一倍。所以GMRES在构造最优多项式时，会把系数0分配给奇数步。 \n\n\n\n所以这就说明了为什么$A_2$的收敛图像会时不时出现一条折线：折线是在奇数步产生的，在奇数步时算法给奇次项系数分配了0这个数，这就会导致在奇数步时实际的多项式仍然与上一步（偶数）的相同，导致误差完全没有发生变化。所以画出来的局部误差图是一条从平滑下降直线突变到斜率为0的直线。拓展到整个迭代过程，就产生了断断续续的折线。\n那我们还是很想知道的是，为什么GMRES算法会能给奇次项分配0？其实GMRES并不是主动去选0，而是因为在奇数步时，生成的那个新方向，刚好和我们想去的方向垂直。\nGMRES 算法在第 $k$ 步时试图寻找一 个系数 $\\alpha$，使得新残差 $||\\mathbf{r}{new}|| = ||\\mathbf{r}{old} - \\alpha \\mathbf{q}{new}||$ 最小。根据最小二乘法原理，最优的 $\\alpha$ 实际上是 $\\mathbf{r}{old}$ 在新方向 $\\mathbf{q}_{new}$ 上的正交投影：\n\n\\alpha = \\frac{\\mathbf{r}_{old} \\cdot \\mathbf{q}_{new}}{||\\mathbf{q}_{new}||^2}在奇数步时，由于矩阵特征值的对称性以及初始向量的平衡性，我们要证明在当前残差向量 $\\mathbf{r}{old}$ 与新生成的方向 $\\mathbf{q}{new}$ 是相互垂直（正交）的，即点积为 0。\n为什么奇数步时新方向与残差向量方向垂直？因为我们有两个关于远点对称的特征值，所以我们可以认为，残差向量$r$，一定由这两个特征值对应的特征向量组成，且这两个向量正交。我们假设r在正负两个方向的分量长度相等（”平衡“）。我们可以把$\\mathbf{r}$写成：$r=u+v$，显然$||u||=||v||$。我们尝试迈出奇数步，算出新方向$q_{new}=Ar$，因为$r$的分解，所以我们又可以写成$Ar=\\lambda u-\\lambda v=\\lambda(u-v)$。现在我们来看残差向量和新向量的点积 \n\n           \\begin{aligned}\n           r·(Ar) &= (u+v)·\\lambda(u-v) \\\\\n                  &= \\lambda[(u+v)(u-v)] \\\\\n                  &= \\lambda[u·u-u·v+v·u-v·v] \\\\\n                  &= \\lambda(||u||^2-||v||^2)\n           \\end{aligned}因为$u$和$v$的大小相等，所以\n\nr(Ar)=\\lambda(||u||^2-||v||^2)=0点积为0，说明两者确实是垂直的。而且因为我们设定的$b$是全1向量，这就导致$b$在正特征值空间的分量，和在负特征值空间的分量，恰好大小相等正是这种完美的对称性，导致了完美的垂直，进而导致了完美的停滞（横线）。如果$b$是随机生成的向量，那么$||u||$和$||v||$就不一定完全相等，垂直条件就会被破坏，那条横线可能就会变成一条”稍微有点斜率“的线，但依然会很慢\n那我们在推理完为什么图像会有”折线“出现时，我们对于$\\mathbf{A_2}$的收敛速度的问题就十分显然了\n因为奇次项的系数为0，我们就相当于在这个什么都没干，就相当于这个奇次项停摆了。所以每当迭代到奇数步时，我们的误差收敛会停滞。这就意味着，我们对比$A_1$执行了$m$次迭代，由于我们的奇数步”瘫痪了“，实际上$A_2$只迭代了$\\frac{m}{2}$次！换句话说，对于$A_2$，我们其实是在构建$p(A_2^2)$，有效迭代次数直接砍半了，自然地，收敛速度也会收到影响。这就解释了图像上显示的$A_2$收敛速度显著慢于$A_1$的现象。\n","tags":["数值分析"]},{"title":"RMSProp","url":"/2026/02/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RMSProp/","content":"\n/* 强制让 MathJax 公式容器支持横向滚动 */\n.mjx-container, .MathJax_Display, .MathJax {\n    overflow-x: auto !important; /* 超出宽度时显示滚动条 */\n    overflow-y: hidden;          /* 隐藏垂直滚动条 */\n    max-width: 100%;             /* 限制最大宽度为屏幕宽度 */\n    -webkit-overflow-scrolling: touch; /* 优化移动端滑动体验 */\n}\n\n\nRMSProp 是一种 自适应学习率方法。它通过计算梯度的二阶矩的指数加权移动平均，来对每个参数的学习率进行独立缩放\n\n\\begin{aligned}\nE[\\mathbf{g}^2]_t &= \\beta E[\\mathbf{g}^2]_{t-1} + (1-\\beta) (\\mathbf{g}_t \\odot \\mathbf{g}_t) \\\\\n\\mathbf{x}_{t+1} &= \\mathbf{x}_t - \\frac{\\eta}{\\sqrt{E[\\mathbf{g}^2]_t + \\epsilon}} \\odot \\mathbf{g}_t\n\\end{aligned}其中\n\n$\\odot$ 表示哈达玛积，即逐元素相乘。\n$E[\\mathbf{g}^2]_t$ 是梯度平方的累积量。\n$\\beta$ 是衰减率（典型值为 0.9 或 0.99）。\n$\\epsilon$ 是防止分母为零的平滑项。\n\n构造与推导我们从RMSProp的根源，AdaGrad开始讲起\n动量法解决了全局震荡的问题，但是我们的所有参数共用一个学习率$\\eta$在处理稀疏特征或尺度差异巨大的参数（例如深度nn的网络）时，我们希望\n\n对于频繁更新或梯度很大的参数，降低其学习率，防止其发散\n对于频繁更新或梯度很大的参数，增大其学习率\n\n为了实现上述目标，我们需要构造一个调节器，这个调节器应该与该方向上的历史梯度的幅度成反比那么，我们该如何衡量一个参数在过去一段时间内的梯度大小？简单的累加梯度$\\sum g_t$肯定是不行的，因为正负梯度会互相抵消（实际上是剧烈震荡）因此，我们必须累加梯度的平方定义$r_t$为知道$t$时刻的所有梯度的平方和\n\nr_t=\\sum_{\\tau=1}^{t}g_\\tau^2现在，我们使用$r_t$作为分母，对全局学习率进行归一化，这就是AdaGrad的核心公式\n\nw_{i+1}=w_i-\\frac{\\eta}{r_t+\\epsilon}\\odot g_t\n$\\epsilon$是一个防止分母为0的常数\n\nAdaGrad的致命缺陷虽然AdaGrad解决了“各向异性”问题，但是在深层神经网络学习的优化场景中，他暴露出了一个致命的问题我们观察$r_t$的定义\n\nr_t = \\sum_{\\tau=1}^{t} g_\\tau^2 = r_{t-1} + g_t^2由于$g_t^2$是非负的，我们会发现，整个式子是单调递增的，也就是说$r_t$是单调递增的！随着训练迭代次数$t$趋近于$\\infty$\n\n$r_t\\to\\infty$\n有效学习率$\\frac{\\eta}{\\sqrt{r_t+\\epsilon}}\\to0$\n\n如果在找到最小值之前，学习率就已经减小到几乎为0，参数更新就会停止，无法到达最优解，这在深度神经网络中是不可接受的\n所以我们引入RMSProp修正我们需要一种方法，既能衡量梯度的大小，又只关注最近的历史，而不是从盘古开天辟地（$t=1$）开始累积我们可以通过指数加权移动平均来实现。我们不再直接求和，而是使用一个衰减系数$\\beta$\nRMSProp 的构造步骤我们将 AdaGrad 的累积公式：\n\nr_t = r_{t-1} + g_t^2修改为 RMSProp 的加权更新公式：\n\nE[g^2]_t = \\beta \\cdot \\underbrace{E[g^2]_{t-1}}_{\\text{历史信息}} + (1-\\beta) \\cdot \\underbrace{g_t^2}_{\\text{当前信息}}步骤解析：\n\n每经过一步，旧的累积量 $E[g^2]_{t-1}$ 就会乘以 $\\beta$（例如 0.9）。这意味着很久以前的梯度信息会以 $0.9, 0.81, 0.729…$ 的速度迅速衰减，不再主导分母\n当前的梯度平方 $g_t^2$ 被赋予权重 $(1-\\beta)$ 加入累积量\n这种方式使得 $E[g^2]_t$ 不再是单调递增的，它变成了一个在该参数梯度平均强度附近的滑动窗口估计量结合上述推导，我们得到了RMSProp的完整形式对于参数 $\\mathbf{w}$ 和梯度 $\\mathbf{g}_t$\n\n\n计算梯度平方的移动平均\n\n\nv_t = \\beta v_{t-1} + (1-\\beta) g_t^2这里常用符号 $v_t$ 或 $h_t$ 表示累积量 $E[g^2]_t$\n\n参数更新\n\n\nw_{t+1} = w_t - \\frac{\\eta}{\\sqrt{v_t + \\epsilon}} g_t这就得到了我们最后的公式\n","tags":["深度学习"]},{"title":"动量法","url":"/2026/02/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E5%8A%A8%E9%87%8F%E6%B3%95/","content":"\n/* 强制让 MathJax 公式容器支持横向滚动 */\n.mjx-container, .MathJax_Display, .MathJax {\n    overflow-x: auto !important; /* 超出宽度时显示滚动条 */\n    overflow-y: hidden;          /* 隐藏垂直滚动条 */\n    max-width: 100%;             /* 限制最大宽度为屏幕宽度 */\n    -webkit-overflow-scrolling: touch; /* 优化移动端滑动体验 */\n}\n\n\n动量法旨在加速 SGD 在相关方向上的收敛，并抑制无关方向上的震荡。在时间步 $t$，给定目标函数 $f(\\mathbf{x})$ 关于参数 $\\mathbf{x}$ 的梯度 $\\mathbf{g}t = \\nabla{\\mathbf{x}} f(\\mathbf{x}_t)$，引入速度向量 $\\mathbf{v}_t$，其更新公式如下\n\n\\begin{aligned}\n\\mathbf{v}_{t+1} &= \\mu \\mathbf{v}_t + \\eta \\mathbf{g}_t \\\\\n\\mathbf{x}_{t+1} &= \\mathbf{x}_t - \\mathbf{v}_{t+1}\n\\end{aligned}其中，$\\mu \\in [0, 1)$ 为 动量系数（通常取 0.9），$\\eta$ 为学习率\n构造与推导考虑一个局部呈现为狭长山谷状地损失函数表面。如果不适用动量，SGD的更新公式为$\\mathbf{x}_{t+1} = \\mathbf{x}_t - \\eta \\mathbf{g}_t$，此时出现两个问题\n\n在山谷的横截面方向（高曲率，梯度大），$\\mathbf{g}_t$很大，导致参数在山谷两壁间剧烈震荡\n在山谷的延伸方向（低曲率，梯度小），$\\mathbf{g}_t$很小，导致收敛的速度极慢\n\n而我们所需要的是，我们希望算法能够记住之前的更新方向，在震荡方向上相互抵消，在平缓方向上累积速度\n我们需要引入一个时间平滑机制\n\n如果连续多次的方向一致（平滑），步长应增大\n如果连续梯度的方向相反（震荡），步长应减小\n\n所以，我们将当前的更新向量不再仅仅设为当前梯度，而是设为当前梯度与过去梯度的指数加权移动平均定义累积变量 $\\mathbf{v}_t$。在 $t=0$ 时，$\\mathbf{v}_0 = 0$。在 $t=1$ 时，$\\mathbf{v}_1 = \\eta \\mathbf{g}_0$。在 $t=2$ 时，我们要保留 $\\mathbf{v}_1$ 的一部分，并加上新的梯度：$\\mathbf{v}_2 = \\mu \\mathbf{v}_1 + \\eta \\mathbf{g}_1$。展开递归式：\n\\mathbf{v}_{t+1} = \\eta \\mathbf{g}_t + \\mu (\\eta \\mathbf{g}_{t-1} + \\mu \\mathbf{v}_{t-1}) = \\eta \\sum_{\\tau=0}^{t} \\mu^{t-\\tau} \\mathbf{g}_\\tau观察此式：\n\n当梯度方向一致时（$\\text{sign}(\\mathbf{g}t) = \\text{sign}(\\mathbf{g}{t-1})$），$\\mathbf{v}$ 的模长会增大，起到加速作用。\n当梯度方向改变时（$\\text{sign}(\\mathbf{g}t) \\neq \\text{sign}(\\mathbf{g}{t-1})$），正负项在求和中互相抵消，起到抑制震荡作用。\n\n","tags":["深度学习","线性回归"]},{"title":"整理一下softmax回归实现中训练部分代码的思路","url":"/2026/02/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8Bsoftmax%E5%9B%9E%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%B8%AD%E8%AE%AD%E7%BB%83%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E7%9A%84%E6%80%9D%E8%B7%AF/","content":"\n/* 强制让 MathJax 公式容器支持横向滚动 */\n.mjx-container, .MathJax_Display, .MathJax {\n    overflow-x: auto !important; /* 超出宽度时显示滚动条 */\n    overflow-y: hidden;          /* 隐藏垂直滚动条 */\n    max-width: 100%;             /* 限制最大宽度为屏幕宽度 */\n    -webkit-overflow-scrolling: touch; /* 优化移动端滑动体验 */\n}\n\n\n在训练前，我们需要利用一些函数来评估模型的分类精度首先，如果y_hat是矩阵，那么假定第二个维度存储每个类的预测分数。 我们使用argmax获得每行中最大元素的索引来获得预测类别。 然后我们将预测类别与真实y元素进行比较。 由于等式运算符“==”对数据类型很敏感， 因此我们将y_hat的数据类型转换为与y的数据类型一致。 结果是一个包含0（错）和1（对）的张量。 最后，我们求和会得到正确预测的数量。def accuracy(y_hat, y):     &quot;&quot;&quot;计算预测正确的数量&quot;&quot;&quot;    if len(y_hat.shape) &gt; 1 and y_hat.shape[1] &gt; 1: # 如果是一个矩阵        y_hat = y_hat.argmax(axis=1) # 获取每一行的最大值    cmp = y_hat.astype(y.dtype) == y # 判断最大值是否与y中的每一行真实的最大值相同    return float(cmp.astype(y.dtype).sum()) # 返回一个正确预测的数量同样，对于任意数据迭代器data_iter可访问的数据集，我们可以评估在任意模型net的精度def evaluate_accuracy(net, data_iter):     &quot;&quot;&quot;计算在指定数据集上模型的精度&quot;&quot;&quot;    metric = Accumulator(2)  # 正确预测数、预测总数    for X, y in data_iter: # 在迭代器中获取数据        metric.add(accuracy(net(X), y), d2l.size(y)) # 计算正确数量    return metric[0] / metric[1] # 返回精度这里我们定义了一个类Accmulator，用于对多个变量进行累加class Accumulator:     &quot;&quot;&quot;在n个变量上累加&quot;&quot;&quot;    def __init__(self, n):        self.data = [0.0] * n # 在声明实例时n有多少就代表着他想返回的精度的条例有多少    def add(self, *args):\t    # 用于对列表中的每一项加上（正确数量，数据总量）        self.data = [a + float(b) for a, b in zip(self.data, args)]    def reset(self):        self.data = [0.0] * len(self.data)    def __getitem__(self, idx):\t    # 定义了__getitem__方法说明了这个类创建的实例可以被索引化        return self.data[idx]\n训练我们先考虑在一个轮次中我们是怎么训练的，这一切还是在代码里用注释讲清楚比较好def train_epoch_ch3(net, train_iter, loss, updater):  #@save    &quot;&quot;&quot;训练模型一个迭代周期&quot;&quot;&quot;    # 将模型设置为训练模式 设置为训练模式时 模型会自动计算梯度    if isinstance(net, torch.nn.Module):        net.train()    # 此时metric.add()方法能返回的是训练损失总和、训练准确度总和、样本数    metric = Accumulator(3)    for X, y in train_iter:        # 计算梯度并更新参数        y_hat = net(X)        # 计算损失        l = loss(y_hat, y)        # 在这里开始我们根据优化器的情况分成两种情况        if isinstance(updater, torch.optim.Optimizer):            # 使用PyTorch内置的优化器和损失函数            updater.zero_grad() # 梯度清空 不然梯度就会被累加            l.mean().backward() # 计算平均梯度            updater.step() # 自动管理 net.parameters()        else:            # 使用定制的优化器和损失函数            l.sum().backward() # 计算总梯度            updater(X.shape[0]) # 把总梯度平均化        metric.add(float(l.sum()), accuracy(y_hat, y), y.numel())    # 返回训练损失和训练精度    return metric[0] / metric[2], metric[1] / metric[2]训练的完整实现def train_ch3(net, train_iter, test_iter, loss, num_epochs, updater):  #@save    &quot;&quot;&quot;训练模型&quot;&quot;&quot;    &#x27;&#x27;&#x27;    animator = Animator(xlabel=&#x27;epoch&#x27;, xlim=[1, num_epochs], ylim=[0.3, 0.9],                        legend=[&#x27;train loss&#x27;, &#x27;train acc&#x27;, &#x27;test acc&#x27;])    &#x27;&#x27;&#x27;    for epoch in range(num_epochs):        train_metrics = train_epoch_ch3(net, train_iter, loss, updater) # 训练一次        test_acc = evaluate_accuracy(net, test_iter) # 测试集的精度        &#x27;&#x27;&#x27;animator.add(epoch + 1, train_metrics + (test_acc,))&#x27;&#x27;&#x27;    train_loss, train_acc = train_metrics # 返回训练集loss和精度    # 如果不符合要求 则报错并抛出后面的值    assert train_loss &lt; 0.5, train_loss    assert train_acc &lt;= 1 and train_acc &gt; 0.7, train_acc    assert test_acc &lt;= 1 and test_acc &gt; 0.7, test_acc\n","tags":["深度学习，线性回归"]},{"title":"LossSumExp技巧（LSE）","url":"/2026/02/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/LossSumExp%E6%8A%80%E5%B7%A7%EF%BC%88LSE%EF%BC%89/","content":"\n/* 强制让 MathJax 公式容器支持横向滚动 */\n.mjx-container, .MathJax_Display, .MathJax {\n    overflow-x: auto !important; /* 超出宽度时显示滚动条 */\n    overflow-y: hidden;          /* 隐藏垂直滚动条 */\n    max-width: 100%;             /* 限制最大宽度为屏幕宽度 */\n    -webkit-overflow-scrolling: touch; /* 优化移动端滑动体验 */\n}\n\n\n在手动实现的softmax和交叉熵损失中，我们在这两步是分步计算的，即我们在计算评估函数Xw+b后，我们先调用softmax计算$\\frac{exp(x_i)}{\\sum exp(x_j)}$，然后再把计算出来的softmax概率直接传给 log 计算交叉熵。但是这种分步计算数值是及其不稳定的，因为我们的softmax计算出来的数值再0到1的区间内，而当数值趋近于0时，很容易遇到数值下溢出导致log(0)报错。这在数值上是十分脆弱的。\n所以我们使用LSE技巧，在损失函数内部，将这两部合并计算\n\n核心逻辑：框架（如 PyTorch 的 nn.CrossEntropyLoss ）要求你传入未规范化的预测\n内部黑盒：在损失函数内部，它并不会先算概率再算对数，而是利用数学恒等式将这两步合并计算\n数学原理：它计算的是$\\log(\\sum exp(x_i))$，并使用了平移技巧（减去最大值c）\n\n\nLogSumExp(x)=c+\\log\\sum exp(x_i-c),\\quad \\text{其中c=max(x)}\n优势：这种合并计算的方式在计算机底层是极其稳定的，永远不会出现NaN（不是数字）或无穷大的错误\n\n接下来我们证明等价性：其中softmax公式：$\\tilde{y}_i=\\frac{exp(x_i)}{\\sum_j exp(x_j)}$交叉熵损失（针对单样本）：$L=-\\log(\\tilde{y}_y)$\n将softmax的定义带入到损失函数L中\n\nL=-\\log(\\tilde{y}_i=\\frac{exp(x_i)}{\\sum_j exp(x_j)})利用对数的运算法则展开\n\nL=-[\\log(exp(x_i))-log(\\sum_{j}exp(x_j))]因为$\\log(exp(x))=x$，所以\n\nL=-[x_i-log(\\sum_{j}exp(x_j))]展开\n\nL=-x_i+\\log(\\sum_{j}exp(x_j))得证\n","tags":["深度学习，线性回归"]},{"title":"随机梯度下降","url":"/2026/02/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/","content":"\n/* 强制让 MathJax 公式容器支持横向滚动 */\n.mjx-container, .MathJax_Display, .MathJax {\n    overflow-x: auto !important; /* 超出宽度时显示滚动条 */\n    overflow-y: hidden;          /* 隐藏垂直滚动条 */\n    max-width: 100%;             /* 限制最大宽度为屏幕宽度 */\n    -webkit-overflow-scrolling: touch; /* 优化移动端滑动体验 */\n}\n\n\n因为梯度下降法需要遍历整个数据集，而在数据集数量庞大的时候，这样做必然会导致爆炸式增长的算法时间复杂度。所以我们在采用梯度下降法进行优化时，我们要在原数据集中随机选取几个且不重复的数据作为子数据集来进行优化迭代。这一种梯度下降法我们就称为随机梯度下降\n","tags":["深度学习","线性回归"]}]